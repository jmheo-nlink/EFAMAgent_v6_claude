#region 변경 이력
/*
 * Author : Link mskoo (2011. 9. 2)
 * 
 * ====================================================================================================================
 * Date         Name            Description of Change
 * --------------------------------------------------------------------------------------------------------------------
 * 2011-09-02   mskoo           최초 작성.
 * 
 * 2011-09-23   mskoo           5.0 버전 릴리즈.
 * ====================================================================================================================
 */
#endregion

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Text;
// log4net 라이브러리
using log4net;
using Link.Core.IO;

namespace Link.EFAM.Agent
{
    using Link.EFAM.Common;
    using Link.EFAM.Engine;
    using Application = System.Windows.Forms.Application;
    using File = System.IO.File;
    using FileInfo = System.IO.FileInfo;
    using Path = System.IO.Path;

    /// <summary>
    /// 액세스 제어와 관련된 작업에 대한 런타임 동작을 제어한다.
    /// </summary>
    class AccessControlBehavior : IAccessControlBehavior
    {
        private static BooleanSwitch m_traceSwitch = new BooleanSwitch("traceSwitch", "AccessControlBehavior");
        private static ILog m_logger = LogManager.GetLogger(typeof(AccessControlBehavior));
        private Dictionary<string, string> m_tempFileExtList = null;

        #region 생성자

        /// <summary>
        /// <see cref="AccessControlBehavior"/> 클래스의 새 인스턴스를 초기화한다.
        /// </summary>
        public AccessControlBehavior()
        {
        }

        #endregion

        #region 메소드

        /// <summary>
        /// 지정한 파일이 임시 파일인지 여부를 확인한다.
        /// </summary>
        /// <param name="filePath">확인할 파일의 전체 경로</param>
        /// <returns>파일이 임시 파일이면 <b>true</b>, 그렇지 않으면 <b>false</b></returns>
        private bool IsTempFile(string filePath)
        {
            string fileExt = NtPath.GetExtension(filePath);

            if (m_tempFileExtList == null) m_tempFileExtList = GetTempFileExtensionList();
            if (fileExt != null)
            {
                return m_tempFileExtList.ContainsKey(fileExt);
            }

            return false;
        }

        /// <summary>
        /// 설정 파일에서 임시 파일 확장자 목록을 가져온다.
        /// </summary>
        /// <returns>임시 파일 확장자 목록</returns>
        private Dictionary<string, string> GetTempFileExtensionList()
        {
            StringBuilder retValue = new StringBuilder();
            string fileName = Path.Combine(Application.StartupPath, "EFAM.ini");
            string sectionName = "AgentProfile";
            string keyName = "TempFileExtensions";
            int capacity = 255;
            int copiedLength = 0;

            do
            {
                retValue.Capacity = retValue.Capacity + capacity;

                copiedLength = NativeMethods.GetPrivateProfileString(
                                sectionName, keyName, "", retValue, retValue.Capacity, fileName);
            } while ((copiedLength + 1) == retValue.Capacity);
            if (m_traceSwitch.Enabled) Trace.WriteLine("[EFAM.Trace] load temp file extensions. " + retValue.ToString());

            Dictionary<string, string> fileExtList = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
            string fileExt = null;

            foreach (string value in retValue.ToString().Split(new char[] { ',' }))
            {
                fileExt = value.Trim();

                if (fileExt.Length == 0 || fileExt[0] == '.')
                {
                    fileExtList[fileExt] = "";
                }
                else
                {
                    fileExtList["." + fileExt] = "";
                }
            } // foreach ( string )

            return fileExtList;
        }

        #endregion

        #region IAccessControlBehavior 멤버

        /// <summary>
        /// 원격 파일 및 디렉토리에 대한 액세스 제어를 활성화하기 전에 추가로 사용자 지정 프로세스를 수행한다.
        /// </summary>
        /// <param name="shareNames">액세스를 제어할 네트워크 공유의 목록</param>
        public void OnActivate(List<string> shareNames)
        {
        }

        /// <summary>
        /// 지정한 경로에 대해 허용되거나 거부된 액세스 권한을 반환하기 전에 추가로 사용자 지정 프로세스를 수행한다.
        /// </summary>
        /// <param name="fileRights">반환할 액세스 권한을 나타내는 <see cref="FileAccessRights"/> 개체</param>
        /// <param name="processInfo">
        /// 액세스 권한을 요청한 프로세스에 대한 정보를 나타내는 <see cref="ProcessInfo"/> 개체
        /// </param>
        /// <param name="path">파일 또는 디렉토리의 경로</param>
        /// <param name="isDir">디렉토리의 경로이면 true, 파일의 경로이면 false</param>
        public void OnGetPermissions(FileAccessRights fileRights, ProcessInfo processInfo, string path, bool isDir)
        {
            switch (processInfo.Kind)
            {
                case ProcessKind.MsOffice:
                    if (!isDir)
                    {
                        if (fileRights.AllowWrite)
                        {
                            fileRights.AllowRename = true;
                            fileRights.AllowDelete = true;
                        }
                    } // if (!isDir)
                    break;

#if INTEROP_SWORK   // ============================================================================
                default:
                    if (!isDir)
                    {
                        if (String.Equals(processInfo.FileName, "SDSEnc.exe", 
                                          StringComparison.OrdinalIgnoreCase))
                        {
                            fileRights.AllowDelete = true;
                            fileRights.AllowRename = true;
                        }
                        else if (processInfo.CreatedFiles.Contains(path.ToLower()))
                        {
                            fileRights.AllowDelete = true;
                            fileRights.AllowRename = true;
                        }
                        // 특정 프로세스에서 임시 파일을 생성할 경우
                        else if (IsTempFile(path) && !File.Exists(path))
                        {
                            fileRights.AllowRead = true;
                            fileRights.AllowWrite = true;
                            fileRights.AllowDelete = true;
                            fileRights.AllowRename = true;
                        }
                    } // if (!isDir)
                    break;
#endif  // INTEROP_SWORK ==========================================================================
            } // switch (processInfo.Kind)
        }

        /// <summary>
        /// 파일 또는 디렉토리에 대해 수행된 작업의 로그를 기록하기 전에 추가로 사용자 지정 프로세스를 수행한다.
        /// </summary>
        /// <param name="processInfo">작업을 수행한 프로세스에 대한 정보를 나타내는 <see cref="ProcessInfo"/> 개체</param>
        /// <param name="path">파일 또는 디렉토리의 경로</param>
        /// <param name="newPath">파일 또는 디렉토리의 새 경로</param>
        /// <param name="action">
        /// 파일 또는 디렉토리에 대해 수행된 작업을 지정하는 <see cref="FileAction"/> 값 중 하나
        /// </param>
        /// <returns>파일 또는 디렉토리에 대해 수행된 작업의 로그를 기록하려면 true, 그렇지 않으면 false</returns>
        /// <remarks>
        /// action 매개 변수가 다음의 값 중 하나일 경우 newPath 매개 변수는 다음과 같은 의미를 갖는다.<br/>
        /// FileDeleted - 휴지통 디렉토리로 백업된 파일의 경로.<br/>
        /// FileRenamed - 새 파일 이름.<br/>
        /// FileMoved - 파일의 새 위치에 대한 경로.<br/>
        /// FileCopied - 관리하는 네트워크 공유가 아닌 위치(로컬 디스크, 네트워크 공유 등)로 복사된 파일의 새 경로.<br/>
        /// DirectoryRenamed - 새 디렉토리 이름.<br/>
        /// DirectoryMoved - 디렉토리의 새 위치에 대한 경로.
        /// </remarks>
        public bool OnWriteLog(ProcessInfo processInfo, string path, string newPath, FileAction action)
        {
            switch (action)
            {
                case FileAction.FileOpened:
                    if (processInfo.Kind == ProcessKind.WindowsExplorer) return false;
                    break;

#if INTEROP_SWORK   // ============================================================================
                case FileAction.FileDeleted:
                    if (IsTempFile(path))
                    {
                        try
                        {
                            FileInfo file = new FileInfo(newPath);

                            file.IsReadOnly = false;
                            file.Delete();
                        } // try
                        catch (Exception)
                        {
                            BackgroundWorker bgWorker = new BackgroundWorker();

                            bgWorker.DoWork += bgWorker_DoWork;
                            bgWorker.RunWorkerAsync(newPath);
                        }
                        
                        return false;
                    } // if (IsTempFile(path))
                    break;
#endif  // INTEROP_SWORK ==========================================================================
            } // switch (action)

            return true;
        }

        #endregion

        #region 이벤트 핸들러

        /// <summary>
        /// 백그라운드 작업이 시작될 때 다른 스레드에서 필요한 작업을 진행한다.
        /// </summary>
        private void bgWorker_DoWork(object sender, DoWorkEventArgs e)
        {
            string path = e.Argument as string;
            FileInfo file = null;

            for (int index = 0; index < 5; index++)
            {
                System.Threading.Thread.Sleep(1000);

                try
                {
                    if (file == null) file = new FileInfo(path);

                    file.IsReadOnly = false;
                    file.Delete();
                    break;
                } // try
                catch (Exception) { }
                //string message = "AccessControlBehavior.OnWriteLog() - " + processInfo + ", File:" + newPath + "\n" + exc;

                //if (m_logger.IsErrorEnabled) m_logger.Error(message);
                //if (m_traceSwitch.Enabled) Trace.WriteLine("[EFAM.Error] " + message);
            } // for (...)
        }

        #endregion
    }
}
